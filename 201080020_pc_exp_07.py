# -*- coding: utf-8 -*-
"""201080020_PC_Exp_07.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1J3EFKJCQBw6DFLLequWPpRbkNnbLrgEH
"""

!apt-get -y update
!apt-get -y install mpich
!pip install mpi4py

"""###Task-1 : Calculate rank and number of processor"""

# Commented out IPython magic to ensure Python compatibility.
# %%writefile mpi_r.c
# #include <mpi.h>
# #include <stdio.h>
# 
# int main(int argc, char** argv) {
#   int rank, size;
# 
#   MPI_Init(NULL, NULL);
#   MPI_Comm_rank(MPI_COMM_WORLD, &rank);
#   MPI_Comm_size(MPI_COMM_WORLD, &size);
# 
#   printf("I am process %d of %d.\n", rank, size);
# 
#   MPI_Finalize();
#   return 0;
# }
#

!mpicc mpi_r.c -o mpi_r
!mpirun --allow-run-as-root -n 1 ./mpi_r

"""###Task-2 : Calculate value of pi """

# Commented out IPython magic to ensure Python compatibility.
# %%writefile mpi_pi.c
# #include <mpi.h>
# #include <stdio.h>
# #include <math.h>
# 
# int main(int argc, char** argv) {
#   int rank, size;
#   long long int n = 1000000;
#   double x, pi, sum = 0.0;
#   int i;
# 
#   MPI_Init(NULL, NULL);
#   MPI_Comm_rank(MPI_COMM_WORLD, &rank);
#   MPI_Comm_size(MPI_COMM_WORLD, &size);
# 
#   for (i = rank; i < n; i += size) {
#     x = (double)(i + 0.5) / (double)n;
#     sum += 4.0 / (1.0 + x * x);
#   }
# 
#   double local_pi = sum / n;
#   MPI_Reduce(&local_pi, &pi, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD);
# 
#   if (rank == 0) {
#     printf("pi is approximately %.16f.\n", pi);
#   }
# 
#   MPI_Finalize();
#   return 0;
# }
#

!mpicc mpi_pi.c -o mpi_pi
!mpirun --allow-run-as-root -np 1 ./mpi_pi

"""###Advanced MPI program that has a total number of 4 processes, where the process with
###rank = 0 should send VJTI letter to all the processes using MPI_Scatter call.
"""

# Commented out IPython magic to ensure Python compatibility.
# %%writefile mpi_vjti.c
# #include <mpi.h>
# #include <stdio.h>
# #include <string.h>
# 
# #define MESSAGE_SIZE 5
# 
# int main(int argc, char** argv) {
#   int rank, size;
#   char message[MESSAGE_SIZE + 1];
# 
#   MPI_Init(NULL, NULL);
#   MPI_Comm_rank(MPI_COMM_WORLD, &rank);
#   MPI_Comm_size(MPI_COMM_WORLD, &size);
# 
#   if (rank == 0) {
#     strcpy(message, "VJTI");
#   }
# 
#   MPI_Scatter(message, MESSAGE_SIZE, MPI_CHAR, message, MESSAGE_SIZE, MPI_CHAR, 0, MPI_COMM_WORLD);
# 
#   printf("Process %d received message: %s\n", rank, message);
# 
#   MPI_Finalize();
#   return 0;
# }
#

!mpicc mpi_vjti.c -o mpi_vjti
!mpirun --allow-run-as-root -np 1 ./mpi_vjti

"""###Task-4: Calculate maximum of array"""

# Commented out IPython magic to ensure Python compatibility.
# %%writefile mpi_maximum.c
# #include <mpi.h>
# #include <stdio.h>
# 
# #define ARRAY_SIZE 6
# 
# int main(int argc, char** argv) {
#   int rank, size;
#   int array[ARRAY_SIZE] = {1, 6, 3, 8, 2, 7};
#   
#   MPI_Init(NULL, NULL);
#   MPI_Comm_rank(MPI_COMM_WORLD, &rank);
#   MPI_Comm_size(MPI_COMM_WORLD, &size);
# 
#   int local_max = array[rank];
#   int max;
# 
#   MPI_Reduce(&local_max, &max, 1, MPI_INT, MPI_MAX, 0, MPI_COMM_WORLD);
# 
#   if (rank == 0) {
#     printf("The maximum value in the array is: %d\n", max);
#   }
# 
#   MPI_Finalize();
#   return 0;
# }
#

!mpicc mpi_maximumm.c -o mpi_maximum
!mpirun --allow-run-as-root -np 1 ./mpi_maximum

"""###Task-5: Ring Topology"""

# Commented out IPython magic to ensure Python compatibility.
# %%writefile mpi_ring.c
# #include <mpi.h>
# #include <stdio.h>
# 
# int main(int argc, char** argv) {
#   int rank, size;
#   int message_in, message_out;
# 
#   MPI_Init(NULL, NULL);
#   MPI_Comm_rank(MPI_COMM_WORLD, &rank);
#   MPI_Comm_size(MPI_COMM_WORLD, &size);
# 
#   if (rank == 0) {
#     message_out = 1;
#     MPI_Send(&message_out, 1, MPI_INT, (rank + 1) % size, 0, MPI_COMM_WORLD);
#     MPI_Recv(&message_in, 1, MPI_INT, size - 1, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
#     printf("Process %d received message %d from process %d.\n", rank, message_in, size - 1);
#   } else {
#     MPI_Recv(&message_in, 1, MPI_INT, rank - 1, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
#     printf("Process %d received message %d from process %d.\n", rank, message_in, rank - 1);
#     if (rank == size - 1) {
#       message_out = 0;
#     } else {
#       message_out = message_in + 1;
#     }
#     MPI_Send(&message_out, 1, MPI_INT, (rank + 1) % size, 0, MPI_COMM_WORLD);
#   }
# 
#   MPI_Finalize();
#   return 0;
# }
#

!mpicc mpi_ring.c -o mpi_ring
!mpirun --allow-run-as-root -np 1 ./mpi_ring

