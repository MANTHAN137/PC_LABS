# -*- coding: utf-8 -*-
"""201080020_PC_Exp4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1l69Ap2SycBoVskpegLON_Mb1lVmLk6qx

**Name**: Manthan Gopal Dhole
 
 **ID**: 201080020
 
 **Programme**: TY Btech IT

 **Subject**: Parallel computing lab

 **Experiment 4**
"""

!apt list --installed

!nvcc --version

"""1"""

# Commented out IPython magic to ensure Python compatibility.
code1 = """
// OpenMP program to print Hello World 
// using C language 
  
// OpenMP header 
#include <omp.h>   
#include <stdio.h> 
#include <stdlib.h> 
  
int main(int argc, char* argv[]) 
{ 
    // Beginning of parallel region 
    #pragma omp parallel 
    { 
        printf("Hello World... from thread = %d \\n", omp_get_thread_num()); 
    } 
    // Ending of parallel region 
}
"""
text_file = open("code1.c", "w")
text_file.write(code1)
text_file.close()
# %env OMP_NUM_THREADS=3
!gcc -o code1 -fopenmp code1.c
!./code1

"""2

"""

# Commented out IPython magic to ensure Python compatibility.
code2 = """

//Code to implement and solve producer consumer problem
//Using OpenMP

#include <stdio.h>
#include <stdlib.h>
#include <omp.h>

#define BUFFER_SIZE 10

int buffer[BUFFER_SIZE];
int count = 0;
int in = 0;
int out = 0;

omp_lock_t lock;

void producer() {
    int item;
    while (1) {
        item = rand() % 100;
        omp_set_lock(&lock);
        if (count < BUFFER_SIZE) {
            buffer[in] = item;
            in = (in + 1) % BUFFER_SIZE;
            count++;
            printf(" Producer produced item %d\\n", item);
        }
        omp_unset_lock(&lock);
        #pragma omp flush
        sleep(1);
    }
}

void consumer() {
    int item;
    while (1) {
        omp_set_lock(&lock);
        if (count > 0) {
            item = buffer[out];
            out = (out + 1) % BUFFER_SIZE;
            count--;
            printf("Consumer consumed item %d\\n", item);
        }
        omp_unset_lock(&lock);
        #pragma omp flush
        sleep(1);
    }
}

int main() {
    omp_init_lock(&lock);
    #pragma omp parallel num_threads(2)
    {
        int tid = omp_get_thread_num();
        if (tid == 0) {
            producer();
        } else {
            consumer();
        }
    }
    omp_destroy_lock(&lock);
    return 0;
}

"""
text_file = open("code2.c", "w")
text_file.write(code2)
text_file.close()
# %env OMP_NUM_THREADS=3
!gcc -o code2 -fopenmp code2.c
!./code2

3

# Commented out IPython magic to ensure Python compatibility.
code3="""
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <omp.h>
#include <sys/time.h>


#define N 5

int A[N][N];
int B[N][N];
int C[N][N];

int main() 
{
    int i,j,k;
    struct timeval tv1, tv2;
    struct timezone tz;
	double elapsed; 
    omp_set_num_threads(omp_get_num_procs());
    for (i= 0; i< N; i++)
        for (j= 0; j< N; j++)
	{
            A[i][j] = 2;
            B[i][j] = 2;
	}
  printf("Matrix A:\\n");
  for (i= 0; i< N; i++)
    {
        for (j= 0; j< N; j++)
        {
            printf("%d\\t",A[i][j]);
        }
        printf("\\n");
    }
  printf("\\nMatrix B:\\n");
  for (i= 0; i< N; i++)
    {
        for (j= 0; j< N; j++)
        {
            printf("%d\\t",B[i][j]);
        }
        printf("\\n");
    }
    gettimeofday(&tv1, &tz);
    #pragma omp parallel for private(i,j,k) shared(A,B,C)
    for (i = 0; i < N; ++i) {
        for (j = 0; j < N; ++j) {
            for (k = 0; k < N; ++k) {
                C[i][j] += A[i][k] * B[k][j];
            }
        }
    }


    gettimeofday(&tv2, &tz);
    elapsed = (double) (tv2.tv_sec-tv1.tv_sec) + (double) (tv2.tv_usec-tv1.tv_usec) * 1.e-6;
    printf("\\nelapsed time = %f seconds.\\n", elapsed);

    printf("\\nThe product:\\n");
    for (i= 0; i< N; i++)
    {
        for (j= 0; j< N; j++)
        {
            printf("%d\\t",C[i][j]);
        }
        printf("\\n");
    }
}
"""
text_file = open("code3.c", "w")
text_file.write(code3)
text_file.close()
# %env OMP_NUM_THREADS=3
!gcc -o code3 -fopenmp code3.c
!./code3

"""4"""

# Commented out IPython magic to ensure Python compatibility.
code4="""
#include <stdio.h>
#include <omp.h>

int is_prime(int n) {
    if (n <= 1) {
        return 0;
    }
    for (int i = 2; i * i <= n; i++) {
        if (n % i == 0) {
            return 0;
        }
    }
    return 1;
}

int main() {
    #pragma omp parallel for
    for (int i = 2; i <= 100; i++) {
        if (is_prime(i)) {
            printf("%d is prime\\n", i);
        }
    }
    return 0;
}
"""
text_file = open("code4.c", "w")
text_file.write(code4)
text_file.close()
# %env OMP_NUM_THREADS=3
!gcc -o code4 -fopenmp code4.c
!./code4

"""5"""

# Commented out IPython magic to ensure Python compatibility.
code5="""
#include <stdio.h>
#include <stdlib.h>
#include <omp.h>

#define ARRAY_SIZE 10

int main()
{
    int i;
    int largest = 0;
    int array[ARRAY_SIZE];

    // initialize the array with random values
    for (i = 0; i < ARRAY_SIZE; i++) {
        array[i] = rand() % 10000;
        printf("%d\\t",array[i]);
    }
    printf("\\n");
    // find the largest element in the array using OpenMP
    #pragma omp parallel for reduction(max:largest)
    for (i = 0; i < ARRAY_SIZE; i++) {
        if (array[i] > largest) {
            largest = array[i];
        }
    }

    printf("The largest element in the array is %d\\n", largest);

    return 0;
}
"""
text_file = open("code5.c", "w")
text_file.write(code5)
text_file.close()
# %env OMP_NUM_THREADS=3
!gcc -o code5 -fopenmp code5.c
!./code5

"""6"""

# Commented out IPython magic to ensure Python compatibility.
code6="""
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <omp.h>

int main() {
    int n = 10000;  // number of iterations
    double x, y, pi;
    int count = 0;

    // set random seed
    srand(time(NULL));

    #pragma omp parallel for private(x, y) reduction(+:count)
    for (int i = 0; i < n; i++) {
        // generate random point (x, y) in [0, 1] x [0, 1]
        x = (double)rand() / RAND_MAX;
        y = (double)rand() / RAND_MAX;

        // test if point is inside unit circle
        if (x * x + y * y <= 1) {
            count++;
        }
    }

    // calculate pi
    pi = 4.0 * count / n;

    printf("pi = %f\\n", pi);

    return 0;
}

"""
text_file = open("code6.c", "w")
text_file.write(code6)
text_file.close()
# %env OMP_NUM_THREADS=3
!gcc -o code6 -fopenmp code6.c
!./code6