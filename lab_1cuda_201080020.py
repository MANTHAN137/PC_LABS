# -*- coding: utf-8 -*-
"""Lab_1Cuda_201080020.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1swGAydL_inxtdS5BryEjwQ0aAckEVIDT
"""

!nvcc --version

!pip install git+https://github.com/andreinechaev/nvcc4jupyter.git

# Commented out IPython magic to ensure Python compatibility.
# %load_ext nvcc_plugin

# Commented out IPython magic to ensure Python compatibility.
# %%cu
# #include <iostream>
# using namespace std;
# int main()
# {
# 	cout << "Welcome To GeeksforGeeks"<<endl<<1;
# 	return 0;
# }
#

# Commented out IPython magic to ensure Python compatibility.
# %%cu
# #include <iostream>
# #include <cstdio>
# 
# using namespace std;
# __global__ void add(int *a,int *b,int *c){
#     *c=*a+*b;
# }
# 
# int main(){
#     int a,b,c; // host copies of a, b, c
#     int *d_a,*d_b,*d_c; // device copies of a, b, c
#     int size=sizeof(int);
# 
#     // Allocate space for device copies of a, b, c
#     cudaMalloc((void **)&d_a,size);
#     cudaMalloc((void **)&d_b,size);
#     cudaMalloc((void **)&d_c,size);
# 
#     a=10,b=3;
# 
#     // Copy inputs to device
#     cudaMemcpy(d_a,&a,size,cudaMemcpyHostToDevice);
#     cudaMemcpy(d_b,&b,size,cudaMemcpyHostToDevice);
# 
#     // Launch add() kernel on GPU
#     add<<<1,1>>>(d_a,d_b,d_c);
# 
#     // Copy result back to host
#     cudaMemcpy(&c,d_c,size,cudaMemcpyDeviceToHost);
# 
#     cout<<c<<endl;
# 
#     //Free the space
#     cudaFree(d_a);
#     cudaFree(d_b);
#     cudaFree(d_c);
# 
#     return 0;
# }

# Commented out IPython magic to ensure Python compatibility.
# %%cu
# #include "stdio.h"
# #include <iostream>
# 
# using namespace std;
# 
# // Defining number of elements in Array
# #define N 10
# 
# __global__ void add(int *a,int *b,int *c){
#     int i=blockIdx.x * blockDim.x + threadIdx.x;
# 
#     if(i<N){
#         c[i]=a[i]+b[i];
#     }
# }
# 
# int main(){
#     int h_a[N],h_b[N],h_c[N];
# 
#     int *d_a,*d_b,*d_c;
# 
#     cudaMalloc((void**)&d_a,N * sizeof(int));
#     cudaMalloc((void**)&d_b,N * sizeof(int));
#     cudaMalloc((void**)&d_c,N * sizeof(int));
#     
#     for (int i = 0; i < N; i++) {
#         h_a[i] = 10;
#         h_b[i] = 2 ;
#     }
# 
#     cudaMemcpy(d_a,h_a,N * sizeof(int),cudaMemcpyHostToDevice);
#     cudaMemcpy(d_b,h_b,N * sizeof(int),cudaMemcpyHostToDevice);
# 
#     add<<<N/2,2>>>(d_a,d_b,d_c);
# 
#     cudaMemcpy(h_c,d_c,N * sizeof(int),cudaMemcpyDeviceToHost);
# 
#     for (int i = 0; i < N; i++) {
#         printf("%d\n",h_c[i]);
#     }
#     
#     return 0;
# }

"""## Addition of Matrix"""

# Commented out IPython magic to ensure Python compatibility.
# %%cu
# #include <stdio.h>
# #include <stdlib.h>
# 
# #define N 5
# #define BLOCK_DIM 10
# 
# __global__ void matrixAdd (int *a, int *b, int *c) {
#     int col = blockIdx.x * blockDim.x + threadIdx.x;
#     int row = blockIdx.y * blockDim.y + threadIdx.y;
# 
#     int index = col + row * N;
# 
#     if (col < N && row < N) {
#         c[index] = a[index] + b[index];
#     }
# 
# }
# 
# int main() {
#     int a[N][N], b[N][N], c[N][N];
#     int *dev_a, *dev_b, *dev_c;
# 
#     int size = N * N * sizeof(int);
# 
#     for(int i=0; i<N; i++)
#         for (int j=0; j<N; j++){
#             a[i][j] = 10;
#             b[i][j] = 2;
#         }
# 
#     cudaMalloc((void**)&dev_a, size);
#     cudaMalloc((void**)&dev_b, size);
#     cudaMalloc((void**)&dev_c, size);
# 
#     cudaMemcpy(dev_a, a, size, cudaMemcpyHostToDevice);
#     cudaMemcpy(dev_b, b, size, cudaMemcpyHostToDevice);
# 
#     dim3 dimBlock(BLOCK_DIM, BLOCK_DIM);
#     //dim3 dimGrid((int)ceil(N/dimBlock.x),(int)ceil(N/dimBlock.y));
#     dim3 dimGrid((N+dimBlock.x-1)/dimBlock.x, (N+dimBlock.y-1)/dimBlock.y);
#     printf("dimGrid.x = %d, dimGrid.y = %d\n", dimGrid.x, dimGrid.y);
#     matrixAdd<<<dimGrid,dimBlock>>>(dev_a,dev_b,dev_c);
#     cudaMemcpy(c, dev_c, size, cudaMemcpyDeviceToHost);
#     printf("Matrix a is:\n");
#     for(int i=0; i<N; i++){
#         for (int j=0; j<N; j++){
#             printf("%d\t", a[i][j] );
#         }
#         printf("\n");
#     }
# 
#     printf("Matrix b is:\n");
#     for(int i=0; i<N; i++){
#         for (int j=0; j<N; j++){
#             printf("%d\t", b[i][j] );
#         }
#         printf("\n");
#     }
# 
#     printf("Result after a*b is:\n");
#     for(int i=0; i<N; i++){
#         for (int j=0; j<N; j++){
#             printf("%d\t", c[i][j] );
#         }
#         printf("\n");
#     }
# 
# 
#     cudaFree(dev_a);
#     cudaFree(dev_b);
#     cudaFree(dev_c);
# }

"""## Multiplication of Matrix"""

# Commented out IPython magic to ensure Python compatibility.
# %%cu
# #include <stdio.h>
# #include <stdlib.h>
# 
# #define N 5
# #define BLOCK_DIM 10
# 
# __global__ void matrixMult (int *a, int *b, int *c) {
#     int col = blockIdx.x * blockDim.x + threadIdx.x;
#     int row = blockIdx.y * blockDim.y + threadIdx.y;
# 
#     
# 
#     if (col < N && row < N) {
#         int tempSum=0;
# 
#         for(int i=0;i<N;i++){
#             tempSum += a[row * N + i] * b[i * N + col];
#         }
# 
#         c[row * N + col] = tempSum;
#     }
# 
# }
# 
# int main() {
#     int a[N][N], b[N][N], c[N][N];
#     int *dev_a, *dev_b, *dev_c;
# 
#     int size = N * N * sizeof(int);
# 
#     for(int i=0; i<N; i++)
#         for (int j=0; j<N; j++){
#             a[i][j] = 3;
#             b[i][j] = 2;
#         }
# 
#     cudaMalloc((void**)&dev_a, size);
#     cudaMalloc((void**)&dev_b, size);
#     cudaMalloc((void**)&dev_c, size);
# 
#     cudaMemcpy(dev_a, a, size, cudaMemcpyHostToDevice);
#     cudaMemcpy(dev_b, b, size, cudaMemcpyHostToDevice);
# 
#     dim3 dimBlock(BLOCK_DIM, BLOCK_DIM);
#     //dim3 dimGrid((int)ceil(N/dimBlock.x),(int)ceil(N/dimBlock.y));
#     dim3 dimGrid((N+dimBlock.x-1)/dimBlock.x, (N+dimBlock.y-1)/dimBlock.y);
#     printf("dimGrid.x = %d, dimGrid.y = %d\n", dimGrid.x, dimGrid.y);
#     matrixMult<<<dimGrid,dimBlock>>>(dev_a,dev_b,dev_c);
#     cudaMemcpy(c, dev_c, size, cudaMemcpyDeviceToHost);
#     printf("Matrix x :\n");
#     for(int i=0; i<N; i++){
#         for (int j=0; j<N; j++){
#             printf("%d\t", a[i][j] );
#         }
#         printf("\n");
#     }
# 
#     printf("Matrix y :\n");
#     for(int i=0; i<N; i++){
#         for (int j=0; j<N; j++){
#             printf("%d\t", b[i][j] );
#         }
#         printf("\n");
#     }
# 
#     printf("Result after x*y :\n");
#     for(int i=0; i<N; i++){
#         for (int j=0; j<N; j++){
#             printf("%d\t", c[i][j] );
#         }
#         printf("\n");
#     }
# 
# 
#     cudaFree(dev_a);
#     cudaFree(dev_b);
#     cudaFree(dev_c);
# }

# Commented out IPython magic to ensure Python compatibility.
# %%cu
# #include <stdio.h>
# #include <stdlib.h>
# 
# #define N 5
# #define BLOCK_DIM 10
# 
# __global__ void matrixTrans(int *ain, int *aout) {
#     int col = blockIdx.x * blockDim.x + threadIdx.x;
#     int row = blockIdx.y * blockDim.y + threadIdx.y;
# 
#     
# 
#     if (col < N && row < N) {
#         aout[col*N+row]=ain[row*N+col];
#     }
# 
# }
# 
# int main() {
#     int a_in[N][N], a_out[N][N];;
#     int *dev_ain, *dev_aout;
# 
#     int size = N * N * sizeof(int);
# 
#     for(int i=0; i<N; i++)
#         for (int j=0; j<N; j++){
#             a_in[i][j] = i*i+j+1;
#         }
# 
#     cudaMalloc((void**)&dev_ain, size);
#     cudaMalloc((void**)&dev_aout, size);
# 
#     cudaMemcpy(dev_ain, a_in, size, cudaMemcpyHostToDevice);
#     cudaMemcpy(dev_aout, a_out, size, cudaMemcpyHostToDevice);
# 
#     dim3 dimBlock(BLOCK_DIM, BLOCK_DIM);
#     //dim3 dimGrid((int)ceil(N/dimBlock.x),(int)ceil(N/dimBlock.y));
#     dim3 dimGrid((N+dimBlock.x-1)/dimBlock.x, (N+dimBlock.y-1)/dimBlock.y);
#     printf("dimGrid.x = %d, dimGrid.y = %d\n", dimGrid.x, dimGrid.y);
#     matrixTrans<<<dimGrid,dimBlock>>>(dev_ain,dev_aout);
#     cudaMemcpy(a_out, dev_aout, size, cudaMemcpyDeviceToHost);
#     printf("Input Matrix is:\n");
#     for(int i=0; i<N; i++){
#         for (int j=0; j<N; j++){
#             printf("%d\t", a_in[i][j] );
#         }
#         printf("\n");
#     }
# 
#     printf("Transpose Matrix is:\n");
#     for(int i=0; i<N; i++){
#         for (int j=0; j<N; j++){
#             printf("%d\t", a_out[i][j] );
#         }
#         printf("\n");
#     }
# 
# }